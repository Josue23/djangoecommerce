SPRINT 1
	layout do projeto, baseado no bootstrap
	- pagina inicial
	- contato
	- pagina de listar produtos
	- pagina de um produto específico

# documentação do django
https://docs.djangoproject.com/en/1.10/

# template do bootstrap usado neste projeto
http://bootswatch.com/flatly/

# reporitório de pacotes django
https://djangopackages.org/

# github do djangoproject
https://github.com/django/django

# site do pypi
https://pypi.python.org/pypi

# adicionar reporitório do python3.5
sudo add-apt-repository ppa:fkrull/deadsnakes

# como instalar virtualenv no python3.5
sudo apt-get install python-virtualenv

# criando o ambiente virtual
# venv é o nome da pasta que vai criar
# -p é a versão do python que vai ser instalado no ambiente virtual
virtualenv venv -p python3.5

# ativando o ambiente virtual, com python3.5 por padrão
source venv/bin/activate

# instalando django 1.9 no ambiente virtual
pip install django==1.9
	Successfully installed django-1.9
	(venv)

# upgrading django to version 1.9.5
pip install -U django==1.9.5

# criando o projeto djangoecommerce no diretório atual
django-admin startproject djangoecommerce .

# arquivo base do meu projeto
# é nele que vou rodar todos os comandos django:
	# rodar o servidor
	# atualizar o banco de dados...etc
manage.py
# levantando o servidor
./manage.py runserver
./manage.py runserver 0.0.0.0:8000 # se eu tiver usando uma VM

====================================================
====================================================
# Aula 6 - primeira app django

# PRIMEIRAS CONFIGURAÇÕES
settings.py
# arquivo com as configuraões gerais do django
	banco de dados, configuraões de envio de e-mail, arquivos estáticos, templates.......etc


# BASE_DIR armazena o diretório raiz do projeto
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
	# caminho absoluto do arquivo
	os.path.abspath(__file__)

	# diretório onde está o settings
	os.path.dirname()

# altera locale de:
# posso ter mais de um idioma no projeto, com locale
LANGUAGE_CODE = 'pt-br'

# altera o timezone para:
TIME_ZONE = 'America/Sao_Paulo'

# CRIANDO MINHA PRIMEIRA APP DJANGO
./manage.py startapp core
	# startapp cria uma aplicação e cria os requisitos mínimos para essa aplicação
	# na app core é onde se coloca as coisas básicas que serão usadas pelas outras apps do meu projeto

# DIZENDO AO DJANGO QUE EXISTE A APP core NO MEU SISTEMA
# em settings.py
INSTALLED_APPS = [
	'core',
]

# altera o arquivo core/views.py
	# insere as linhas:
# coding=utf-8

# sempre que eu precisar criar uma url, eu tenho que ter uma view associada à ela

# o django consiste em mapeamento (com regex) de urls em funções, que são as views

# edita urls.py
urlpatterns = [
    url(r'^$'), # r indica que é uma string regex '^$' indica que é a url mãe
    url(r'^admin/', admin.site.urls),
]
====================================================
====================================================
AULA 7 - Sistema de templates(Template tags, Variáveis e filtros)
settings.py
	TEMPLATES = [
		'DIRS': [], # é uma lista de diretórios onde eu vou encontrar os meus templates
					- templates pode ser uma página html, txt, qualquer arquivo de texto com marcação

		'APP_DIRS': True, # vou procurar templates dentro de uma pasta chamada templates que está dentro de cada aplicação

# crio a pasta templates dentro de core
$ mkdir core/templates
# estou dizendo ao django para procurar templates dentro de core/templates

# crio index.html
$ touch core/templates/index.html

# marcação especial django templates
variáveis
{{ title }} # vai carregar o valor de title, que vem de um context
- context  é um dicionário com chave e valor, declarado na view

- tem também marcação especial de templates tags
- templates tags vão alterar o fluxo da minha página
ex: eu tenho uma lista de produtos, faço um for para iterar sobre esta lista de produtos

- filtros, servem para formatar a minha saída


====================================================
====================================================
AULA 8 - trabalhando com arquivos estáticos
settings.py
INSTALLED_APPS = [
	# como o django serve arquivos estáticos:
	- o django procura uma pasta chamada static dentro de cada app
	'django.contrib.staticfiles',
]

settings.py
# o caminho d arquivo estático
STATIC_URL = '/static/'
====================================================
# pode-se criar também uma pasta de arquivos estáticos  global para o projeto:
settings.py
STATICFILES_DIRS = [  # que é uma lista de diretórios alternativos
	os.path.join(BASE_DIR, 'staticfiles') # staticfiles é a pasta global na raiz do projeto
]

O django só serve arquivo estático se:
- 'django.contrib.staticfiles', # tiver ativa
- ./manage.py runserver         # rodar o projeto com o runserver
- DEBUG = True                  # estar em modo debug
====================================================
# indicando a url dos arquivos estáticos, carregando os arquivos estáticos
<!DOCTYPE html>
{% load static %}
<link rel="stylesheet" href="{% static 'assets/bootstrap.min.css' %}" media="screen" />
<link rel="stylesheet" href="{% static 'assets/custom.min.css' %}" media="screen" />
<script src="{% static 'assets/bootstrap.min.js' %}"></script>
====================================================
====================================================
AULA 9 - Criando templates com herança
- copio todo o conteúdo de /core/templates/index.html para:
	- /core/templates/base.html
- removo o miolo do /core/templates/base.html
====================================================
abro /core/templates/index.html
- ctrl+x em todo o conteúdo do arquivo

- insiro esta linha no arquivo /core/index.html
{% extends "base.html" %}
estou indicando que ele deve herdar do templates base.html e ele deve preencher somente oa blocos que o base.html definiu
====================================================
- em base.html 
aqui é um possível local  onde eu posso criar html nos filhos

<title>{% block title %}Django E-Commerce{% endblock %}</title>
{% block container %}{% endblock %}
====================================================
- em index.html


====================================================
urls.py
- é boa prática sempre nomear as urls para poder chamar as urls depois em qualquer lugar do projeto

- segue exemplo e nomes e uso dos nomes:
em urls.py
urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^contato/$', views.contact, name='contact'),
    url(r'^produto/$', views.product, name='product'),
    url(r'^produtos/$', views.product_list, name='product_list'),
    url(r'^admin/', admin.site.urls),
]

em base.html
<a href="{% url 'contact' %}">Contato</a>
====================================================
====================================================
AULA 10 - adicionando os primeiros testes
from django.test import TestCase, Client
TestCase é a classe que representa um teste unitário
Client simula o navegador. nos testes

test_views.py


class IndexViewTestCase(TestCase):
	pass

Teste classe IndexViewTestCase que herda de TestCase
- no miolo da classe eu escrevo os métodos dessa classe que vão representar um teste específico

- quero saber se a view index está retorno o código HTTP 200
def test_status_code(self):
====================================================
====================================================
AULA 11 - Deply do sistema no Heroku
- no terminal na miha máquina
$ heroku login
Logged in as josuerodrigues@gmail.com

criando chave ssh
$ ssh-keygen -t rsa -C "josuerodrigues@gmail.com"

verificando minha chave ssh puvlic
$ cat ~/.ssh/id_rsa.pub

adicionando minha chave ~/.ssh/id_rsa.pub ao heroku
$ heroku keys:add

- adicionando a url git que o heroku me forneceu
- o git permite que o meu repositório local esteja no linkado ao github, herokue mais outros repositórios externos
- linkando  este repositório com o heroku
$ git remote add heroku https://git.heroku.com/djangoe-commerce.git

- verificando
$ git remote -v
heroku	https://git.heroku.com/djangoe-commerce.git (fetch)
heroku	https://git.heroku.com/djangoe-commerce.git (push)

libs que precisam ser instaladas antes de fazer o deploy no heroku
$ pip install dj-database-url==0.4.1
$ pip install gunicorn==19.4.5
$ pip install -U django==1.9.6
$ pip install psycopg2==2.6.1


djangoecommerce/settings.py
import os
import dj_database_url

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
- a diferença entre BASE_DIR e o PROJECT_ROOT é que BASE_DIR é relatico ao diretório raiz
- o PROJECT_ROOT é na pasta settings


# gerar um arquivo com as libs que estão instaladas no meu virtualenv
$ pip freeze > requirements.txt

# crio o arquivo runtime.txt com a versão do python instalado
$ python --version > runtime.txt

# crio o arquivo Procfile com o conteúdo:
- assim o vai rodar o runserver, no heroku, como se tivesse em desenvolvimento
web: python manage.py runserver 0.0.0.0:$PORT


$ git commit -am "primeiro deploy no heroku"
$ git push heroku master 

====================================================
====================================================
====================================================
====================================================
SPRINT 2
Nova app (Catalog)
essa app vai armazenar as informações de cadastro do produtos e categorias 

vamos criar nesse modulo
- app Catalog
- modelagem de produtos
- modelagem da categoria associada a um produto
- cadastrar produtos, categorias e fazer pequenas customizações através do django admin

django admin é uma aplicação do django que serve para cadastrosem forma de CRUD

====================================================
abordagem para que as configurações funcionem tanto em ambiente de desenvolvimento quanto em ambiente de produção

opção 1
local_settings.py
- é um arquivo que vai sobreescrever algumas configurações de produção e vai ser adicionado ao .gitignore

settings.py tem as configurações gerais de ambiente de produção
local_settings.py tem as configurações de ambiente de desenvolvimento

o local_settings.py está no gitignore e não subir para o repositório mas o local_settings.py.example vai poder subir para o repositório
====================================================
AULA 15 - Criando a app catalog
$ ./manage.py migrate
- busca todos os modelos dentro do meu projeto e vai criar as tabelas associadas a esses modelos
- o django gera arquivos de migração que são coisas que devem ser inseridas no banco de dados de acordo com a sua modelagem, sua classe
$ ./manage.py migrate quando rodado pela primeira vez, cria o db.sqlite3 com as tabelas iniciais

pedaço da saída do comendo:
$ ./manage.py migrate
Operations to perform:
  Apply all migrations: admin, sessions, contenttypes, auth
Running migrations:
  Rendering model states... DONE
  Applying contenttypes.0001_initial... OK

Criando a app catalog
./manage.py startapp catalog
- abro o arquivo:
catalog/models.py que é o arquivo dos models associados à app catalog
- crio os modelos que são as classes que representam as tabelas do nosso banco de dados da app catalog

class Category(models.Model):
- toda classe que herdar de models.Model vai ser um modelo que representa uma tabela no banco de dados
- exemplo de nome de campo na tabela
name = models.CharField('nome') representa campo de texto

- depois de eu criar os meus modelos eu adiciono a minha app 'catalog' nas apps instaladas em settings.py

- adicionando os modelos no meu banco de dados:
- gera um arquivo de migração
$ ./manage.py makemigrations
Migrations for 'catalog':
  0001_initial.py:
    - Create model Category
    - Create model Product

criou o arquivo 0001_initial.py

agora a migração de verdade
$ ./manage.py migrate
Operations to perform:
  Apply all migrations: admin, catalog, contenttypes, auth, sessions
Running migrations:
  Rendering model states... DONE
  Applying catalog.0001_initial... OK

====================================================
====================================================
aula16-visualizando-tabelas-no-banco-de-dados.mp4


====================================================
====================================================
aula17-acessando-ORM-atraves-do-shell-do-django

$ pip install  ipython
$ ./manage.py shell

In [1]: from catalog.models import Product, Category 

- todo model do django tem uma referencia para objects que é um manager intermediário entre a consulta do bando e o meu modelo
- com o objects(manager) eu consigo acessar as minhas consultas(QuerySet)

O sistema de ORM do django tem tres principais componentes:
	- model, que criamos
	- manager, este aqui
		-	In [2]: Category.objects
			Out[2]: <django.db.models.manager.Manager at 0x7f87882b29b0>
				- é criado de forma dinamica
	- In [3]: Category.objects.all()
		- como se fosse o SELECT ALL, vai selecionar todos os objects

	In [3]: type(Category.objects.all())
	Out[3]: django.db.models.query.QuerySet

	Category é um model
	In [4]: Category
	Out[4]: catalog.models.Category

	.objects é do tipo manager
	In [5]: Category.objects
	Out[5]: <django.db.models.manager.Manager at 0x7f87882b29b0>

- chamada de uma QuerySet para criar um objeto
In [7]: Category.objects.create()

criando a categoria Programação
In [7]: Category.objects.create(name='Programação', slug='programacao')
Out[7]: <Category: Category object>

In [8]: Category.objects.all()   # já tenho um objeto na saída
Out[8]: [<Category: Category object>]

pegando a primeira categoria, parecido com o 1º índice em python
In [11]: cat = Category.objects.all()[0]

In [12]: cat
Out[12]: <Category: Category object>

- criando meu produto direto pelo ORM do django
In [13]: Product.objects.create(name='Curso de Django', slug='curso-de-django', category=cat, price=100 )
Out[13]: <Product: Product object>

- exibindo o produto
In [14]: Product.objects.all()
Out[14]: [<Product: Product object>]


- query se existe algum produto que contém 'django' no nome
In [16]: Product.objects.filter(name__icontains='django')
Out[16]: [<Product: Product object>]

pegando apenas o slug curso-de-django
	- o get retorna apenas um item
In [21]: Product.objects.get(slug='curso-de-django')
Out[21]: <Product: Product object>

====================================================
====================================================
aula18-djangoAdmin

arquivo catalog/admin.py
- insere as linhas
	from .models import Product, Category
	admin.site.register(Category)
	admin.site.register(Product)


====================================================
====================================================
aula19-customizando-django-admin

dentro de cada aplicãção tem o arquivo apps.py

altero o arquivo catalog/apps.py
adiciono:
	class CatalogConfig(AppConfig):
	    name = 'catalog'
	    verbose_name = 'Catálogo'

altero catalog/__init__.py
	default_app_config = 'catalog.apps.CatalogConfig'


====================================================
====================================================
aula20-listando-as-categorias

core/views.py
adiciono:
from catalog.models import Category

- crio context na view index
def index(request):
	context = {
	'categories': Category.objects.all()
	}
	return render(request, 'index.html', context)
- render é um atalho
- render sendo um atalho, precisa de request, template (index.html) e um dicionário que é o context que vai renderizar dentro de index.html

- no core/templates/index.html só tem o miolo do site
- no core/templates/base.html tem os menus de nav com categorias, onde posso alterar

- quando eu preciso que alguma informação do meu banco, do meu sistema esteja disponível em todos os templates, a melhor coisa a se fazer é:
	usar o context_processors que está no settings.py, TEMPLATES
	- context_processors são fuñções que são chamadas toda vez que o template for renderizado

- vou criar na minha app catalog o arquivo:
catalog/context_processors.py



====================================================
====================================================
aula21-listando-os-produtos

o sistema de templates do django procura uma pasta chamada templates dentro de cada app no meu projeto

- crio a pasta catalog/templates
- crio outra pasta catalog/templates/catalog

vamos usar url include, separar as urls por módulo
- dentro de cada app:
	- crio urls.py
	- coloco somente as urls da app
catalog/urls.py


